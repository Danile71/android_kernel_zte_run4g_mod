////////////////////////////////////////////////////////////////////////
//
// MPDSchema.h
//
// This file was generated by XMLSpy 2012r2sp1 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////

#ifndef _INCLUDED_MPDSchema_H_
#define _INCLUDED_MPDSchema_H_

#include "xs-types.h"
#include "Node.h"
#include "MPDSchema-typeinfo.h"



#define MPDSchema_EXPORT


namespace MPDSchema
{

	class TypeBase
	{
	protected:
		xercesc::DOMNode* m_node;
	public:
		TypeBase(xercesc::DOMNode* const& node) : m_node(node) {}
		xercesc::DOMNode* GetNode() const { return m_node; }

		MPDSchema_EXPORT xercesc::DOMNode* GetElementNth(const altova::MemberInfo* member, unsigned index);
		MPDSchema_EXPORT xercesc::DOMNode* GetElementLast(const altova::MemberInfo* member);
		MPDSchema_EXPORT unsigned CountElement(const altova::MemberInfo* member);
		MPDSchema_EXPORT void RemoveElement(const altova::MemberInfo* member);
		MPDSchema_EXPORT static int GetEnumerationIndex( const string_type sValue, const unsigned enumOffset, const unsigned enumCount);
		MPDSchema_EXPORT static string_type GetEnumerationValue( const int index, const unsigned enumOffset, const unsigned enumCount);
	};

	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	class MemberAttribute
	{
		TypeBase& m_owner;
	public:
		typedef const MemberType& argument_type;
		typedef MemberType return_type;

		MemberAttribute(TypeBase& owner) : m_owner(owner) {}
		void operator=(argument_type value);
		operator return_type();
		bool exists();
		void remove();
		int GetEnumerationValue();
		void SetEnumerationValue(const int index);
		altova::meta::Attribute info() const { return altova::meta::Attribute(members + MemberIndex); }
	};

	template <typename MemberType>
	class CastAs 
	{
	public:
		static MemberType Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember);
	};

	template <>
	inline bool CastAs<bool>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToBool(node, pMember);
	}

	template <>
	inline double CastAs<double>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToDouble(node, pMember);
	}

	template <>
	inline int CastAs<int>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToInt(node, pMember);
	}

	template <>
	inline unsigned CastAs<unsigned>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToUInt(node, pMember);
	}

	template <>
	inline __int64 CastAs<__int64>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToInt64(node, pMember);
	}

	template <>
	inline unsigned __int64 CastAs<unsigned __int64>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToUInt64(node, pMember);
	}

	template <>
	inline string_type CastAs<string_type>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToString(node, pMember);
	}

	template <>
	inline std::vector<unsigned char> CastAs<std::vector<unsigned char> >::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToBinary(node, pMember);
	}

	template <>
	inline altova::DateTime CastAs<altova::DateTime>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToDateTime(node, pMember);
	}

	template <>
	inline altova::Duration CastAs<altova::Duration>::Do(xercesc::DOMNode* const& node, const altova::MemberInfo* pMember)
	{
		return XercesTreeOperations::CastToDuration(node, pMember);
	}

	template <typename DataType>
	class Iterator : public DataType
	{
		XercesTreeOperations::MemberIterator m_it;
	public:
		Iterator(const XercesTreeOperations::MemberIterator& it) : DataType(0), m_it(it) { if (m_it) this->m_node = *m_it; }
		bool operator++() { if (++m_it) { this->m_node = *m_it; return true; } return false; }
		operator bool() const { return m_it; }		

		DataType& operator*() { return *this; }
		DataType* operator->() { return this; }
	};

	template <typename MemberType, unsigned MemberIndex>
	class MemberElement
	{
		TypeBase& m_owner;
	public:
		MemberElement(TypeBase& owner) : m_owner(owner) {}
		MemberType operator[](unsigned index);
		MemberType first();
		MemberType last();
		MemberType append();
		bool exists();
		unsigned count();
		void remove();
		void remove(unsigned index);
		altova::meta::Element info() const { return altova::meta::Element(members + MemberIndex); }

		Iterator<MemberType> all() { return XercesTreeOperations::GetElements(m_owner.GetNode(), members + MemberIndex); }
	};

	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	void MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::operator=(argument_type value)
	{
		XercesTreeOperations::SetValue(m_owner.GetNode(), members + MemberIndex, value);
	}

	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::operator typename MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::return_type()
	{
		xercesc::DOMNode* att = XercesTreeOperations::FindAttribute(m_owner.GetNode(), members + MemberIndex);
		if (!XercesTreeOperations::IsValid(att))
			throw altova::InvalidOperationException(_T("Cannot read value of non-existent attribute."));
		return CastAs<MemberType>::Do(att, members + MemberIndex);
	}

	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	bool MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::exists()
	{
		xercesc::DOMNode* att = XercesTreeOperations::FindAttribute(m_owner.GetNode(), members + MemberIndex);
		return XercesTreeOperations::IsValid(att);
	}

	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	void MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::remove()
	{
		XercesTreeOperations::RemoveAttribute(m_owner.GetNode(), members + MemberIndex);
	}
	
	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	int MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::GetEnumerationValue() {
		xercesc::DOMNode* att = XercesTreeOperations::FindAttribute(m_owner.GetNode(), members + MemberIndex);
		if (!XercesTreeOperations::IsValid(att))
			throw altova::InvalidOperationException(_T("Cannot read value of non-existent attribute."));
		string_type sValue = CastAs<string_type>::Do(att, members + MemberIndex);
		return TypeBase::GetEnumerationIndex( sValue, types[members[MemberIndex].DataType].Facets + EnumOffset, EnumCount);
	}

	template <typename MemberType, unsigned MemberIndex, unsigned EnumOffset, unsigned EnumCount>
	void MemberAttribute<MemberType, MemberIndex, EnumOffset, EnumCount>::SetEnumerationValue(const int index) 
	{
		XercesTreeOperations::SetValue(m_owner.GetNode(), members + MemberIndex, TypeBase::GetEnumerationValue(index, types[members[MemberIndex].DataType].Facets + EnumOffset, EnumCount) );
	}

	template <typename MemberType, unsigned MemberIndex>
	MemberType MemberElement<MemberType, MemberIndex>::operator[](unsigned index)
	{
		return m_owner.GetElementNth(members + MemberIndex, index);
	}

	template <typename MemberType, unsigned MemberIndex>
	MemberType MemberElement<MemberType, MemberIndex>::first()
	{
		return m_owner.GetElementNth(members + MemberIndex, 0);
	}

	template <typename MemberType, unsigned MemberIndex>
	MemberType MemberElement<MemberType, MemberIndex>::last()
	{
		return m_owner.GetElementLast(members + MemberIndex);
	}

	template <typename MemberType, unsigned MemberIndex>
	MemberType MemberElement<MemberType, MemberIndex>::append()
	{
		return XercesTreeOperations::AddElement(m_owner.GetNode(), members + MemberIndex);
	}

	template <typename MemberType, unsigned MemberIndex>
	bool MemberElement<MemberType, MemberIndex>::exists()
	{
		return m_owner.GetElementNth(members + MemberIndex, 0) != 0;
	}

	template <typename MemberType, unsigned MemberIndex>
	unsigned MemberElement<MemberType, MemberIndex>::count()
	{
		return m_owner.CountElement(members + MemberIndex);
	}

	template <typename MemberType, unsigned MemberIndex>
	void MemberElement<MemberType, MemberIndex>::remove()
	{
		m_owner.RemoveElement(members + MemberIndex);
	}

	template <typename MemberType, unsigned MemberIndex>
	void MemberElement<MemberType, MemberIndex>::remove(unsigned index)
	{
		XercesTreeOperations::RemoveElement(m_owner.GetNode(), members + MemberIndex, index);
	}

}

namespace MPDSchema
{
// Namespace: http://www.w3.org/2001/XMLSchema 
// SchemaPrefix: xs

namespace xs
{	
class CENTITIES;
class CENTITY;
class CID;
class CIDREF;
class CIDREFS;
class CNCName;
class CNMTOKEN;
class CNMTOKENS;
class CNOTATION;
class CName;
class CQName;
class CanySimpleType;
class CanyType;
class CanyURI;
class Cbase64Binary;
class Cboolean;
class Cbyte;
class Cdate;
class CdateTime;
class Cdecimal;
class Cdouble;
class Cduration;
class Cfloat;
class CgDay;
class CgMonth;
class CgMonthDay;
class CgYear;
class CgYearMonth;
class ChexBinary;
class Cint;
class Cinteger;
class Clanguage;
class Clong;
class CnegativeInteger;
class CnonNegativeInteger;
class CnonPositiveInteger;
class CnormalizedString;
class CpositiveInteger;
class Cshort;
class Cstring;
class Ctime;
class Ctoken;
class CunsignedByte;
class CunsignedInt;
class CunsignedLong;
class CunsignedShort;
class CanyURIType;
class CstringType;

} // namespace xs

// Namespace: urn:mpeg:dash:schema:mpd:2011 
// SchemaPrefix: 

class CAdaptationSetType;
class CAdaptationSetType_ex;
class CBaseURLType;
class CConditionalUintType;
class CContentComponentType;
class CContentProtectionType;
class CDescriptorType;
class CFormatVersionType;
class CMPDtype_ex;
class CMPDtype;
class CMS3Type;
class CMarlinBroadbandType;
class CMarlinContentIdsType;
class CMetricsType;
class CMultipleSegmentBaseType_ex;
class CMultipleSegmentBaseType;
class CPeriodType_ex;
class CPeriodType;
class CPresentationType;
class CProgramInformationType;
class CRangeType;
class CRepresentationBaseType_ex;
class CRepresentationBaseType;
class CRepresentationType_ex;
class CRepresentationType;
class CSAPType;
class CSegmentBaseType_ex;
class CSegmentBaseType;
class CSegmentListType_ex;
class CSegmentListType;
class CSegmentTemplateType_ex;
class CSegmentTemplateType;
class CSegmentTimelineType_ex;
class CSegmentTimelineType;
class CSegmentURLType;
class CStringVectorType;
class CSubRepresentationType;
class CSubsetType;
class CUIntVectorType;
class CURLType;
class CVideoScanType;
class CMPDSchema;
class CSType_ex;
class CSType;

}

// include individual types

// namespace "http://www.w3.org/2001/XMLSchema"
#include "type_xs.CENTITIES.h"
#include "type_xs.CENTITY.h"
#include "type_xs.CID.h"
#include "type_xs.CIDREF.h"
#include "type_xs.CIDREFS.h"
#include "type_xs.CNCName.h"
#include "type_xs.CNMTOKEN.h"
#include "type_xs.CNMTOKENS.h"
#include "type_xs.CNOTATION.h"
#include "type_xs.CName.h"
#include "type_xs.CQName.h"
#include "type_xs.CanySimpleType.h"
#include "type_xs.CanyType.h"
#include "type_xs.CanyURI.h"
#include "type_xs.Cbase64Binary.h"
#include "type_xs.Cboolean.h"
#include "type_xs.Cbyte.h"
#include "type_xs.Cdate.h"
#include "type_xs.CdateTime.h"
#include "type_xs.Cdecimal.h"
#include "type_xs.Cdouble.h"
#include "type_xs.Cduration.h"
#include "type_xs.Cfloat.h"
#include "type_xs.CgDay.h"
#include "type_xs.CgMonth.h"
#include "type_xs.CgMonthDay.h"
#include "type_xs.CgYear.h"
#include "type_xs.CgYearMonth.h"
#include "type_xs.ChexBinary.h"
#include "type_xs.Cint.h"
#include "type_xs.Cinteger.h"
#include "type_xs.Clanguage.h"
#include "type_xs.Clong.h"
#include "type_xs.CnegativeInteger.h"
#include "type_xs.CnonNegativeInteger.h"
#include "type_xs.CnonPositiveInteger.h"
#include "type_xs.CnormalizedString.h"
#include "type_xs.CpositiveInteger.h"
#include "type_xs.Cshort.h"
#include "type_xs.Cstring.h"
#include "type_xs.Ctime.h"
#include "type_xs.Ctoken.h"
#include "type_xs.CunsignedByte.h"
#include "type_xs.CunsignedInt.h"
#include "type_xs.CunsignedLong.h"
#include "type_xs.CunsignedShort.h"
#include "type_xs.CanyURIType.h"
#include "type_xs.CstringType.h"

// namespace "urn:mpeg:dash:schema:mpd:2011"
#include "type_.CAdaptationSetType.h"
#include "type_.CBaseURLType.h"
#include "type_.CConditionalUintType.h"
#include "type_.CContentComponentType.h"
#include "type_.CContentProtectionType.h"
#include "type_.CDescriptorType.h"
#include "type_.CFormatVersionType.h"
#include "type_.CMPDtype.h"
#include "type_.CMS3Type.h"
#include "type_.CMarlinBroadbandType.h"
#include "type_.CMarlinContentIdsType.h"
#include "type_.CMetricsType.h"
#include "type_.CMultipleSegmentBaseType.h"
#include "type_.CPeriodType.h"
#include "type_.CPresentationType.h"
#include "type_.CProgramInformationType.h"
#include "type_.CRangeType.h"
#include "type_.CRepresentationBaseType.h"
#include "type_.CRepresentationType.h"
#include "type_.CSAPType.h"
#include "type_.CSegmentBaseType.h"
#include "type_.CSegmentListType.h"
#include "type_.CSegmentTemplateType.h"
#include "type_.CSegmentTimelineType.h"
#include "type_.CSegmentURLType.h"
#include "type_.CStringVectorType.h"
#include "type_.CSubRepresentationType.h"
#include "type_.CSubsetType.h"
#include "type_.CUIntVectorType.h"
#include "type_.CURLType.h"
#include "type_.CVideoScanType.h"
#include "type_.CMPDSchema.h"
#include "type_.CSType.h"
#include "MPDParser.h"
#include "type_.CSType_ex.h"
#include "type_.CAdaptationSetType_ex.h"
#include "type_.CMultipleSegmentBaseType_ex.h"
#include "type_.CPeriodType_ex.h"
#include "type_.CRepresentationType_ex.h"
#include "type_.CMPDtype_ex.h"
#include "type_.CSegmentBaseType_ex.h"
#include "type_.CSegmentListType_ex.h"
#include "type_.CSegmentTemplateType_ex.h"



// finished

#endif //_INCLUDED_MPDSchema_H_
