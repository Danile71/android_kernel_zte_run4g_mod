////////////////////////////////////////////////////////////////////////
//
// MPDSchemaTest.cpp
//
// This file was generated by XMLSpy 2012r2sp1 Enterprise Edition.
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the XMLSpy Documentation for further details.
// http://www.altova.com/xmlspy
//
////////////////////////////////////////////////////////////////////////

#include "mpdschema_test_prefix.h"
#include "MPDSchema.h"
#include <iostream>
#include <string>

#include "mpd_extern.h"
#include "dash_debug.h"
using namespace std;



#ifdef _DEBUG

    #undef THIS_FILE
    static char THIS_FILE[] = __FILE__;
#endif


#if 0
void Example(std::string& file)
{
    ////////////////////////////////////////////////////////////////////
    //
    // TODO:
    //   Insert your code here...
    //
    // Example code to create and save a structure:
    //   MPDSchema::CMPDSchema doc = MPDSchema::CMPDSchema::CreateDocument();
    //   MPDSchema::CMPDtype root = doc.MPD.append();
       MPDSchema::CMPDSchema doc = MPDSchema::CMPDSchema::LoadFromFile(file);
       MPDSchema::CMPDtype root = doc.MPD.first();

       if(root.id.exists())
       {
           std::string  id = (std::string)root.id;
           tcout << "id :" << id << std::endl;
       }

       if(!root.profiles.exists())
       {
           tcout << "profile not exists" << std::endl;
           root.profiles = std::string("xxxxxxxxxxxxxxxx");
       }

       if(root.profiles.exists())
        tcout << "profile exists" << std::endl;

       std::string profile = (std::string)root.profiles;

       tcout << "profiles :" << profile << std::endl;

       if(root.mediaPresentationDuration.exists())
       {
           altova::Duration duration = root.mediaPresentationDuration;

           tcout << duration.DayTime().Seconds() << std::endl;
       }



        xercesc::DOMNode* node = root.GetNode();

        xercesc::DOMElement* current = dynamic_cast<xercesc::DOMElement*>(node);
        XMLCh* tag = xercesc::XMLString::transcode("type");

        const XMLCh* xml_type = current->getAttribute(tag);
        char* type_value = xercesc::XMLString::transcode(xml_type);

        tcout << "type " << type_value << endl;
       
       if(root.Period.count() > 0)
       {
           tcout << "Period number:" << root.Period.count() << endl;

           for(unsigned index = 0; index < root.Period.count(); ++ index)
           {
               MPDSchema::CPeriodType period = root.Period[index];

               if(period.id.exists())
               {
                   tcout << "index " << index << "id " << (std::string)period.id << endl;
               }


               if(period.AdaptationSet.count())
               {
                   tcout << "adaptationSet number: " << period.AdaptationSet.count() << endl;

                   for(unsigned i = 0; i < period.AdaptationSet.count(); ++ i)
                   {
                       MPDSchema::CAdaptationSetType adaptation = period.AdaptationSet[i];

                       if(adaptation.Role.count() > 0)
                       {
                           tcout << "role schemeURI " << (std::string) adaptation.Role[0].schemeIdUri << endl;
                       }

                       if(adaptation.AudioChannelConfiguration.count() > 0)
                       {
                           tcout << "AudioChannelConfiguration: " << (std::string) adaptation.AudioChannelConfiguration[0].value2 << endl;
                       }



                       
                   }
               }
           }
       }
       std::string save_file = file.append("save");
    //   ...
       doc.SaveToFile(save_file, true);
    //
    // You must release the document at the end (in both cases)
      doc.DestroyDocument();
    //   ...
    //   doc.SetSchemaLocation(_T("D:/MPEGDA~1/spec/NEWFOL~1/MPDSchema.xsd")); // optional
    //   doc.SaveToFile(_T("MPDSchema1.xml"), true);
    //
    // Example code to load and save a structure:
    //   MPDSchema::CMPDSchema doc = MPDSchema::CMPDSchema::LoadFromFile(_T("MPDSchema1.xml"));
    //   MPDSchema::CMPDtype root = doc.MPD.first();
    //   ...
    //   doc.SaveToFile(_T("MPDSchema1.xml"), true);
    //
    // You must release the document at the end (in both cases)
    //   doc.DestroyDocument();
    //
    ////////////////////////////////////////////////////////////////////
}

#endif

int main(int argc, char* argv[])

{
    tcout << _T("MPDSchema Test Application") << endl;
    
    if(argc < 2)
    {
        tcout << "please input xml path for test" << endl;
        return 1;
    }

    std::string file = std::string(argv[1]);

#if 0
    MPDParser mpd_parser;
    if(!mpd_parser.init())
    {
        tcout << "init error\n" << endl;
        return 1;
    }

    if(mpd_parser.parser(file))
    {
        tcout << "parser error" << endl;
        return 1;
    }

    if(!mpd_parser.destory())
    {
        tcout << "destory error" << endl;
        return 1;
    }
#endif


    void* inst = mpeg_dash_create_inst();
	IMTK_DASH_MPD_T table;
	memset(&table, 0, sizeof(IMTK_DASH_MPD_T));

	if(inst == NULL)
	{
	    MPD_PARSER_DBG(("create instance failed\n"));
	    return 1;
	}

	IMTK_DASH_PB_ERROR_CODE_T ret = mpeg_dash_add_url_to_inst(argv[1],inst);

	if(ret == IMTK_DASH_PB_ERROR_CODE_LAST)
	{
	    MPD_PARSER_DBG(("empty mpd\n"));
		goto end;
	}
	else if(ret != IMTK_DASH_PB_ERROR_CODE_OK)
	{
	    MPD_PARSER_DBG(("mpd parser error\n"));
		goto end;
	}


	if(mpeg_dash_create_segment_table(&table,inst) != IMTK_DASH_PB_ERROR_CODE_OK)
	{
	    MPD_PARSER_DBG(("create segment table failed\n"));

		goto end;
	}

	file.append("table");

	if(write_table_into_filepath(&table, file.c_str()) != 0)
	{
	    MPD_PARSER_DBG(("write table error\n"));
	}
	
end:
	if(table.ptBaseUrls != NULL)
	{
	    IMtkDashPb_Table_free_BaseUrl(table.ptBaseUrls);
	}

	while(table.ptPeroid != NULL)
    {
       IMTK_DASH_PERIOD_T* ptr = table.ptPeroid->ptNext;
       IMtkDashPb_Table_free_Period(table.ptPeroid);
       table.ptPeroid = ptr;

    }
    return 0;
#if 0
    try
    {
        xercesc::XMLPlatformUtils::Initialize();

        Example(file);

        xercesc::XMLPlatformUtils::Terminate();

        tcout << _T("OK") << endl;
        return 0;
    }
    catch (CXmlException& e)
    {
        tcerr << _T("Error: ") << e.GetInfo().c_str() << endl;
        return 1;
    }
    catch (xercesc::XMLException& e)
    {
        tcerr << _T("Xerces XMLException: ") << e.getSrcFile() << _T("(")
              << e.getSrcLine() << _T("): ") << e.getMessage() << endl;
        return 1;
    }
    catch (xercesc::DOMException& e)
    {
        tcerr << _T("Xerces DOMException ") << e.code;
        if (e.msg)
            tcerr << _T(": ") << e.msg;
        tcerr << endl;
        return 1;
    }
    catch (altova::Exception& exception)
    {
        tcerr << "Exception: " << exception.message() << endl;
        return 1;
    }
    catch (altova::Error& exception)
    {
        tcerr << "Error: " << exception.message() << endl;
        return 1;
    }
    catch (std::exception& e)
    {
        cerr << "Exception: " << e.what() << endl;
        return 1;
    }
    catch (...)
    {
        tcerr << _T("Unknown error") << endl;
        return 1;
    }
#endif
}
